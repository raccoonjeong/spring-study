20250922 보충수업


함수 -> 이전에는 문제 전체를 하나로 봐서 대충 만들었다
       어느 한 부분에 문제가 생기면 시스템 전체가 문제가 된다.
       능력자가  퇴직을 한다.
       유지보수
       A - 급여계산 프로그램을 만들고 퇴직홤
       노동법 개정, 단체협약, 취업규칙 등등 영향을 미치는 요소가 많아서
       프로그램을 계속 수정되어야 한다.

       모듈화 -> 코드를 작은단위로 쪼개자(함수)
       하나의 함수가 문제가 생겨도 자기가 다 처리해야 한다. 다른 함수에
       영향을 안미치도록 설계해야 한다
       1. 작게
       2. 한가지 일에만 집중하자

변수,.........   1만개
함수, ................ 1만개

student_name : 스네이크 표기법
studentName : 카멜표기법

관련있는 변수끼리 묶어보자 -> 구조체

java
  클래스 - 관련 있는 변수와 함수의 묶음
  회사 커지면 - 조직을 갖추고 조직에 사람과 돈을 줘야 한다, 업무

  클래스 - 사용자가 만든 새로운 데이터 타입이다.
  class Student{...........................}

  메모리는 이렇게 만든다
  int a;  -- 값타입과 참조타입이 있다
            값타입 - int, long, float, double, char
            참조타입 - String, 그 밖에 사용자가 만든 클래스들

  값타입은 -> 변수 선언과 동시에 메모리가 확보가 된다.
  a = 10;
  참조타입 -> 변수 선언해도 메모리가 없음, 데이터가 들어갈 공간이 없다.

  프로그램 - 실행 -> 프로세스(이름이 바뀐다)
  각 프로세스마다 정적메모리, 스택, 힙 3개의 메모리가 할당된다.
  정적메모리에는 static이 붙은 변수나 전역변수, 기호상수등이 저장된다.
  자바에는 전역변수는 없다.
  스택에는 값타입이 저장된다. 관리자가 os
  힙은 os가 개발자에게 권한을 넘긴다. 이 메모리는 자유롭게 사용가능하다
  참조타입은 힙 공간에 데이터 저장공간을 만들고 이 곳에 데이터를 저장한다

  int a;  바로사용가능
  Integer b;  -- 아직 메모리 없음 참조형변수임
  b = new Integer(); 힙공간에 메모리 할당
  변수  b에는 값이 있는곳의 주소(참조)가 들어간다.

  c언어
  int a;  //값타입
  int *aa; //참조타입 - 포인터

  aa = &a; //변수a의 주소 값 저장

  arr[3][4] = 12;
  *(*(arr+3)+4) = 12;
  모든 타입이 값 <=> 참조를 왔다 갔다. 문법이 너무 어렵다

  aa = new int[10];  os한테 정수 저장할 공간 10개만 줘
  .......
  delete []aa; // 반납 - 개발자들이 반납을 알아서 해야 하는데 안함
  메모리 누스 문제


  메모리 관리 시스템 - 자바가상머신(GC-gabage collector)

  자바의 참조타입은 배열과 클래스만 , 메모리 관리 -닷넷, 시스템이 알아서

기본

 application                application
-----                     -----------------
 os                           jvm, 닷넷,
-----                     -----------------
  hw                           os
                          ------------------
                               hw

예전에는 windows 번역기과   리눅스 os번역기가 다르다
        번역기가 os 에 맞춰서 새로 번역을 해준다

int <=> Integer 차이점
자바는 값타입과 참조타입이 고정인데  값타입이 때로는 참조타입이 되어야 할
때가 있음 , Wrapper 클래스, Integer, Double, ...

Object -> 최상위클래스
List list = new ArrayList();
list.add(1);
list.add("2");
list.add(new Student());

add(Object ob);   1 -> Integer -> Object

int a = (Integer)list.get(0);
String b = (String)list.get(1);
Student c = (Student)list.get(2);

//Generic ->java 5부터
List<Integer>  mlist = new ArrayList<Integer>();
mlist.add(1);
mlist.add(3);

List - 추상화클래스, 객체를 못 만든다
ArrayList - 클래스, 객체 생성이 가능하다

List<Integer>  mlist = new ArrayList2<Integer>();

모던스크립트  ecmascript, 바닐라스크립트,  자바스크립트
타입스크립트 -> angular (자바스크립트는 변수선언을 안한다.
모던스크립트 + 타입 )


자바클래스

객체지향의 특성
  1. 추상화 <=> 구체화 - 특정 클래스 내부의 구조를 모두 다 알아야 한다
     ArrayList 클래스 만들어볼까?
     추상화라는 말은 사용자가 내부 구조를 몰라도 쓰기 편한 상태를 말함
     추상화를 직접 구현하는 사람은 어렵다.
     클래스 - 내부에 변수도 있고 함수도 있다.
   2. 캡슐화
    데이터 보호 차원 , 접근권한, private, public, protected

   반성을 하게 된다. => lombok  @Getter, @Setter, @NoArgumentConstructor
    보일러플레이트 - 반드시 해야 하는 코드, 지루하다.
                   getter/setter, 생성자
    let count;
    count = document.getElementById("count").value;
    count++;
    document.getElementById("count").value = count;

  3. 상속성
  extends  상속을 하게되면 코드의 재사용률이 높아진다. => 프레임워크
  상속, 어노테이션으로 대체

  4. 다형성 , 이름이 같은데 형태가 여러개인 성격
  자바 - 오버로딩, 함수가 이름이 같은데 형태가 다르다. 매개변수의 형태가
         개수가 달라서 서로 구분이 된다.
         System.out.println( )
         오버라이딩 - 상속받는 쪽에서 부모 클래스의 함수를 다시 정의한다

  자바스크립트 - 오버로딩 X , 매개변수에 기본값을 주면 형태가 여러개로 보인다



