# 2. Context API 이해하기

## 1. Context API란?

Context API는 **컴포넌트 트리 어디서든 공통으로 써야 하는 값**(로그인 사용자, 테마, 언어 등)을 props 없이 바로 꺼내 쓰게 하는 리액트의 내장 기능입니다.

## 2. 왜 필요한가 — Prop Drilling 문제

리액트는 데이터가 위(부모) → 아래(자식) 로 흘러갑니다. 로그인 사용자 user를 최하위 컴포넌트에서 쓰려면, 중간 컴포넌트들이 실제로 쓰지 않더라도 props로 계속 전달해야 합니다. 이를 **Prop Drilling**이라 합니다.

- 코드가 길어지고, 어디서 값이 오는지 추적이 어렵습니다.

- 중간 컴포넌트도 상위 값 변경에 반응해 불필요하게 리렌더링됩니다.

- 화면 구조가 바뀔 때마다 props 연결을 다 고쳐야 하니 유지보수 비용이 큽니다.

**Context**는 “공유 상자(Provider)”를 트리 상단에 두고, 하위 어디에서든 **useContext**로 바로 꺼내 쓰는 방식으로 이 문제를 해결합니다.

## 3. 언제 쓰면 좋은가 / 언제 피해야 하는가

### 적합

- 로그인 사용자/토큰, 권한, UI 테마(light/dark), 언어(i18n), 기능 플래그, 앱 환경설정 등 전역적이고 많은 곳에서 필요한 값

- 값은 가끔 변하지만, 여러 화면에서 공통으로 필요

### 비권장

- 입력창의 타이핑처럼 아주 자주 변하는 지역 상태

- 대용량 리스트의 스크롤 위치 등 빠른 빈도의 변화
  - 이런 것은 로컬 useState/useReducer 또는 가벼운 전역 상태 관리 라이브러리(Zustand 등)를 검토

### 동작 흐름

1. createContext()로 채널을 만든다.

2. 트리 상단에 <Context.Provider value={...}>를 둔다.

3. 하위 컴포넌트에서 useContext(Context)로 현재 value를 읽는다.

4. Provider의 value가 바뀌면 그 값을 구독하는 하위가 리렌더링된다.

- 실무 포인트: Provider의 value는 객체/함수 참조가 매 렌더마다 바뀌지 않도록 **useMemo**/**useCallback**으로 안정화하는 것이 좋습니다.

## 4. 커스텀훅 예: 테마 토글(라이트/다크)

### 컨텍스트와 Provider 만들기

```jsx
// theme-context.js
import { createContext, useContext, useMemo, useState } from "react";

const ThemeContext = createContext(null);

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  const value = useMemo(
    () => ({
      theme,
      toggleTheme: () => setTheme((t) => (t === "light" ? "dark" : "light")),
    }),
    [theme]
  ); // value 참조 안정화

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
}

export function useTheme() {
  const ctx = useContext(ThemeContext);
  if (!ctx) throw new Error("useTheme must be used within <ThemeProvider>");
  return ctx;
}
```

### 사용하기

```jsx
// App.jsx
import { ThemeProvider, useTheme } from "./theme-context";

function Toolbar() {
  const { theme, toggleTheme } = useTheme();
  return (
    <div>
      <div>현재 테마: {theme}</div>
      <button onClick={toggleTheme}>테마 전환</button>
    </div>
  );
}

export default function App() {
  return (
    <ThemeProvider>
      <Toolbar />
    </ThemeProvider>
  );
}
```

핵심: 어디서든 useTheme()만 호출하면 props 없이 테마를 읽고 바꿀 수 있습니다.

## 5. 커스텀훅 예: 로그인 상태

### 예제: 로그인 상태 공유(간단하게)

```jsx
// auth-context.js
import {
  createContext,
  useContext,
  useMemo,
  useCallback,
  useState,
} from "react";

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null); // { id, name } | null

  const login = useCallback(async (id, pw) => {
    // 서버 요청이 있다고 가정
    await new Promise((r) => setTimeout(r, 300));
    setUser({ id: 1, name: "홍길동" });
  }, []);

  const logout = useCallback(() => setUser(null), []);

  const isLoggedIn = !!user;
  const value = useMemo(
    () => ({
      user,
      isLoggedIn,
      login,
      logout,
    }),
    [user, login, logout]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("useAuth must be used within <AuthProvider>");
  return ctx;
}
```

### 사용:

```jsx
// Header.jsx
import { useAuth } from "./auth-context";

export default function Header() {
  const { user, isLoggedIn, login, logout } = useAuth();
  return (
    <header>
      {isLoggedIn ? (
        <>
          <span>{user.name}님</span>
          <button onClick={logout}>로그아웃</button>
        </>
      ) : (
        <button onClick={() => login("demo", "pass")}>로그인</button>
      )}
    </header>
  );
}
```

## 6. 성능·안정성 팁 (현업에서 중요한 4가지)

### (1) Provider value는 반드시 useMemo

value={{ user, login }}를 매 렌더마다 새로 만들면 하위가 모두 다시 그려집니다.

### (2) 읽기/쓰기 분리 패턴

값(Context for state)과 액션(Context for dispatch)을 두 컨텍스트로 분리하면, 액션이 바뀔 때 값 구독자 리렌더를 줄일 수 있습니다.

### (3) 컨텍스트 쪼개기

서로 연관 없는 값(테마 vs 사용자)을 하나에 몰아 넣지 말고 Provider를 나눌 것. 바뀌는 범위를 줄여 성능을 지킵니다.

### (4) 빠르게 변하는 값은 Context 말고 로컬 상태로 관리

타이핑/마우스 위치 같은 값은 Context가 아닌 로컬 useState로 두어 리렌더 범위를 좁혀 주세요.
