# 1. useMemo와 useCallback

## 1. 리액트 렌더링의 기본 원리

리액트는 **상태**(state) 또는 **프롭스**(props)가 변경될 때마다 해당 컴포넌트를 다시 렌더링합니다.

여기서 “**렌더링**”이란 컴포넌트 함수를 다시 실행한다는 의미입니다.

예를 들어 다음과 같은 컴포넌트가 있다고 가정해 봅시다.

```jsx
import { useState } from "react";

function Example() {
  const [count, setCount] = useState(0);
  const value = 10;
  console.log("컴포넌트 렌더링 시작");

  function calculate() {
    console.log("계산 실행");
    return value * 2;
  }

  const result = calculate();

  return (
    <div>
      <h1 className="text-lg mb-4 font-bold">useMemo Example</h1>
      <div>value: {value}</div>
      <div>result = {result}</div>
      <div>렌더링 카운트: {count}</div>

      <div>
        <button onClick={() => setCount(count + 1)} className="border px-2">
          렌더링 하기
        </button>
      </div>
    </div>
  );
}
export default Example;
```

위 컴포넌트에서 value가 변경되면,

1. Example 함수 전체가 다시 실행됩니다.

2. 내부의 calculate() 함수도 다시 실행됩니다.

3. 계산 결과가 다시 반환되고, 변경된 부분이 DOM에 반영됩니다.

즉, 리액트는 작은 부분만 바꾸는 것이 아니라 컴포넌트 전체 함수를 실행하여 변경 여부를 확인합니다.

이 방식은 단순하면서도 일관성이 있지만, **불필요하게 동일한 계산이 반복 실행**될 수 있다는 단점이 있습니다.

## 2. 렌더링 과정과 성능 문제

리액트 렌더링은 다음 순서로 진행됩니다.

1. **상태 또는 프롭스 변경**

- setState 호출, 부모에서 내려오는 프롭스 값 변경 등

2. **컴포넌트 함수 재실행** (렌더 단계)

- 함수 내부의 변수, 함수 정의, 계산식 모두 다시 실행

3. **가상 DOM 생성** (Virtual DOM)

- 새로운 UI 구조를 메모리에 구성

4. **차이점 비교하면서 바뀐 곳만 찾아서 반영** (Diffing, 디핑)

- 이전 가상 DOM과 비교해 변경된 부분만 실제 DOM에 반영

이 과정에서 함수나 계산식이 매번 새로 실행되는 것이 문제의 핵심입니다.

예를 들어,

- 대규모 배열을 필터링하거나 정렬하는 로직

- 복잡한 수학 계산(예: 소수 판별, 경로 탐색 알고리즘)

- 매번 새로운 객체나 함수를 생성해서 자식 컴포넌트에 전달하는 경우

이런 작업들은 **렌더링마다 불필요하게 반복되면 성능 저하**를 일으킬 수 있습니다.

## 3. useMemo의 필요성

useMemo는 계산 결과를 **메모이제이**(memoization) 해주는 훅입니다. 즉, 의존성 배열 내 값이 바뀌지 않았다면 이전에 계산한 결과를 재사용합니다.

- **메모이제이** memoization : 기억되어야 할 것이라는 뜻의 라틴어에서 파생된 단어로, 컴퓨터 프로그램이 동일한 계산을 반복적으로 해야 할 때, 이전에 계산한 값을 메모리에 저장했다가 필요할 때 재사용함으로써 속도 및 성능을 높이는 방식을 뜻함.

```js
const memoizedValue = useMemo(() => {
  return 복잡한계산();
}, [의존성]);
```

복잡한계산()은 매 렌더링마다 실행되지 않습니다.

오직 [의존성] 배열에 지정된 값이 바뀔 때만 실행됩니다.

그 외의 경우에는 기존 계산 결과를 그대로 사용합니다.

### 예시

```js
const filteredList = useMemo(() => {
  return items.filter((item) => item.includes(keyword));
}, [items, keyword]);
```

items나 keyword가 바뀌지 않는 한, filter 연산은 다시 실행되지 않습니다.

따라서 렌더링 비용이 크게 줄어듭니다.

### 테스트하기

```jsx
import { useState, useMemo } from "react";

function Example() {
  const [count, setCount] = useState(0);
  const [value, setValue] = useState(10);

  console.log("컴포넌트 렌더링 시작");

  // value가 변경될 때만 재계산
  const result = useMemo(() => {
    console.log("계산 실행");
    return value * 2;
  }, [value]);

  return (
    <div>
      <h1 className="text-lg mb-4 font-bold">useMemo Example</h1>
      <div>value: {value}</div>
      <div>result = {result}</div>
      <div>렌더링 카운트: {count}</div>

      <button onClick={() => setCount(count + 1)} className="border px-2 mr-2">
        렌더링 하기
      </button>

      <button onClick={() => setValue(value + 1)} className="border px-2">
        value 증가
      </button>
    </div>
  );
}

export default Example;
```

## 4. useCallback의 필요성

useMemo가 연산의 결과 값을 메모이제이션 했다면 useCallback은 함수 자체를 메모이제이션합니다.

리액트에서 함수는 매 렌더링마다 새로 만들어집니다.

```jsx
function App() {
  const [count, setCount] = useState(0);

  // 매 렌더링마다 새로운 함수가 생성됨
  const handleClick = () => {
    setCount((prev) => prev + 1);
  };

  return <button onClick={handleClick}>증가</button>;
}
```

위 코드에서는 handleClick 함수가 렌더링될 때마다 새로 생성됩니다.
만약 **이 함수를 자식 컴포넌트의 props로 전달**한다면, 자식 컴포넌트는 매번 새로운 함수가 넘어왔다고 생각해서 불필요하게 리렌더링될 수 있습니다.

이를 방지하기 위해 useCallback을 사용합니다.

```jsx
const handleClick = useCallback(() => {
  setCount((prev) => prev + 1);
}, []);
```

[] 의존성 배열이 비어 있으므로, 이 함수는 처음 한 번만 생성되고 이후에는 같은 참조가 재사용됩니다.

따라서 자식 컴포넌트에 전달해도 리렌더링을 최소화할 수 있습니다.

## 5. useMemo vs useCallback

- useMemo: 값(연산 결과)을 메모이제이션

- useCallback: 함수 자체를 메모이제이션

둘 다 성능 최적화를 위해 사용되며,

**계산 비용이 큰 경우에는 useMemo,
자식 컴포넌트에 함수를 props로 넘겨줄 때는 useCallback**을 사용하는 것이 일반적입니다.

## 6. 최적화 테스트하기

### useCallback + memo() 사용전

```jsx
import { useState, memo } from "react";

const Child = memo(function Child({ onAdd }) {
  console.log("[Child] 렌더링");
  return <button onClick={onAdd}>자식에서 +1</button>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  // 매번 새 함수가 생성됨 → 자식에게 다른 props로 전달됨
  const handleAdd = () => setCount((c) => c + 1);

  console.log("[App] 렌더링");

  return (
    <div>
      <h2>Before: useCallback 없음</h2>
      <p>count: {count}</p>
      <Child onAdd={handleAdd} />
      <input value={text} onChange={(e) => setText(e.target.value)} />
    </div>
  );
}
```

### useCallback + memo() 사용후

```jsx
import { useState, useCallback, memo } from "react";

const Child = memo(function Child({ onAdd }) {
  console.log("[Child] 렌더링");
  return <button onClick={onAdd}>자식에서 +1</button>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  // 참조 고정 → props 동일성 유지
  const handleAdd = useCallback(() => setCount((c) => c + 1), []);

  console.log("[App] 렌더링");

  return (
    <div>
      <h2>After: useCallback 사용</h2>
      <p>count: {count}</p>
      <Child onAdd={handleAdd} />
      <input value={text} onChange={(e) => setText(e.target.value)} />
    </div>
  );
}
```

- memo()는 props가 안 변하면 렌더링을 생략하는 최적화 도구

- useCallback이나 useMemo와 함께 쓰면 props 참조 동일성을 보장할 수 있어 효과가 커집니다

- memo()는 무조건 쓰는 것이 아니라, 자식 컴포넌트가 리렌더링 비용이 클 때 전략적으로 사용하는 것이 좋습니다

## 7. 최적화가 필요한 이유

리액트는 가상 DOM과 효율적인 Diffing 알고리즘을 사용하기 때문에 기본적으로 빠른 편입니다.

그러나 실제 프로젝트에서는 다음과 같은 상황에서 성능 문제가 발생할 수 있습니다.

- 대규모 데이터 처리

- 수천 개의 리스트를 필터링하거나 정렬할 때

- 복잡한 계산 반복

- 렌더링마다 실행되는 수학적 연산, API 호출 준비 로직

- 불필요한 자식 리렌더링

- 부모 컴포넌트가 리렌더링되면서 props로 전달된 함수가 매번 새로 생성될 때

이러한 문제를 줄이는 것이 곧 사용자 경험(UX)과 직결됩니다.
화면이 느려지거나 입력 반응이 늦어지는 것은 사용자 만족도를 크게 떨어뜨리기 때문입니다.

## 8. 정리

리액트는 상태/프롭스 변경 → 컴포넌트 재실행 → 가상 DOM 비교 → 실제 DOM 반영 순서로 렌더링이 진행됩니다.

이 과정에서 불필요한 계산이나 함수 생성이 반복될 수 있습니다.

useMemo는 값 계산을 캐싱하고, useCallback은 함수 참조를 캐싱하여 성능을 최적화합니다.

모든 경우에 무조건 사용하는 것은 바람직하지 않으며, 연산 비용이 큰 경우나 자식 컴포넌트 최적화가 필요한 경우에 전략적으로 사용하는 것이 중요합니다.
