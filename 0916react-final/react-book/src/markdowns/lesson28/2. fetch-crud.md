# 2. fecth로 CRUD 구현하기

## async 함수 사용법

### 1. 함수 선언식 (Function Declaration)

```js
// 함수 선언식
async function fetchData() {
  try {
    const res = await fetch("http://localhost:4000/posts");
    const data = await res.json();
    console.log("데이터:", data);
  } catch (err) {
    console.error(err);
  }
}
// 호출
fetchData();
```

function 키워드 앞에 async 붙이면 됩니다.

호이스팅(hoisting) 되므로, 코드 상단에서 호출해도 동작합니다.

### 2. 함수 표현식 (Function Expression)

```js
// 함수 표현식
const fetchData = async function () {
  try {
    const res = await fetch("http://localhost:4000/posts/1");
    const data = await res.json();
    console.log("데이터:", data);
  } catch (err) {
    console.error(err);
  }
};

// 호출
fetchData();
```

변수에 함수를 대입하는 형태.

호이스팅 안 되므로, 선언 이후에만 호출할 수 있습니다.

### 3. 화살표 함수 표현식 (Arrow Function Expression)

```js
// 화살표 함수
const fetchData = async () => {
  try {
    const res = await fetch("http://localhost:4000/posts/2");
    const data = await res.json();
    console.log("데이터:", data);
  } catch (err) {
    console.error(err);
  }
};

fetchData();
```

함수 표현식의 한 형태.

콜백 함수로 전달할 때 많이 씁니다. (예: useEffect, map 등)

### 정리

- 선언식: async function 이름() {} → 호이스팅 됨.

- 표현식: const 이름 = async function() {} → 호이스팅 안 됨.

- 화살표 함수: const 이름 = async () => {} → 표현식의 간단한 형태, useEffect/콜백 등에 자주 사용.

## Create (POST)

```js
const createPost = async () => {
  try {
    const res = await fetch("http://localhost:4000/posts", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        title: "새 글",
        content: "내용입니다",
        category: "js",
      }),
    });
    const data = await res.json();
    console.log("생성 결과:", data);
  } catch (err) {
    console.error(err);
  }
};
```

## Read (GET)

```js
const readPosts = async () => {
  try {
    // 전체 목록
    const resList = await fetch("http://localhost:4000/posts");
    const list = await resList.json();
    console.log("목록:", list);

    // 특정 id 읽기
    const resOne = await fetch("http://localhost:4000/posts/1");
    const one = await resOne.json();
    console.log("상세:", one);
  } catch (err) {
    console.error(err);
  }
};
```

## Update (PUT / PATCH)

```js
const updatePost = async () => {
  try {
    const res = await fetch("http://localhost:4000/posts/1", {
      method: "PUT", // PATCH도 가능
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        title: "수정된 글",
        content: "내용을 고쳤습니다",
        category: "life",
      }),
    });
    const data = await res.json();
    console.log("수정 결과:", data);
  } catch (err) {
    console.error(err);
  }
};
```

## Delete (DELETE)

```js
const deletePost = async () => {
  try {
    const res = await fetch("http://localhost:4000/posts/1", {
      method: "DELETE",
    });
    if (res.ok) {
      console.log("삭제 성공");
    } else {
      console.error("삭제 실패:", res.status);
    }
  } catch (err) {
    console.error(err);
  }
};
```

- fetch는 항상 Promise를 반환 → await으로 결과 기다림

- res.json()도 Promise → 역시 await 필요

- CRUD는 method만 바꿔서 처리
