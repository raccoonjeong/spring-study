# 1. ContextAPI 최적화

## 1. 언제 최적화를 해야할까?

### ContextAPI 기본 동작

```jsx
<AuthContext.Provider value={{ isAuth, login, logout }}>
  {children}
</AuthContext.Provider>
```

- Context Provider에서 value로 객체를 내려주면, 이 value가 새로 만들어질 때마다 자식 컴포넌트가 전부 리렌더링 됩니다.

- 보통은 단순한 값(state, boolean, string 등)만 내려주면 문제가 안 됩니다.

### useMemo()가 필요한 경우

```jsx
const value = useMemo(
  () => ({ isAuth, login, logout }),
  [isAuth, login, logout]
);

<AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
```

- value에 객체나 함수를 직접 넣을 때, 매 렌더링마다 새로운 참조(reference)가 생겨서 불필요한 리렌더링이 발생할 수 있습니다.

- 이런 상황에서 useMemo나 useCallback을 써서 참조를 안정적으로 유지하면 최적화가 됩니다.

### 결론

- 필수는 아님 → 단순한 값 내려줄 때는 그냥 써도 무방.

- 최적화 용도 → context value가 자주 바뀌지 않는데, 불필요한 리렌더가 많을 경우 useMemo/useCallback을 적용.

정리하면: Context API는 useMemo 없이도 잘 동작하지만, 성능 최적화가 필요할 때만 선택적으로 사용하는 것이 좋습니다.

## 2. useMemo 없이 쓴 경우

```jsx
import { createContext, useContext, useState, memo } from "react";

const AuthContext = createContext(null);

function AuthProvider({ children }) {
  const [isAuth, setIsAuth] = useState(false);

  const login = () => setIsAuth(true);
  const logout = () => setIsAuth(false);

  // 매 렌더링마다 value 객체가 새로 생성됨
  const value = { isAuth, login, logout };
  console.log("AuthProvider 렌더링");

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// memo로 부모 리렌더 시 불필요한 재호출을 회피 (컨텍스트 값이 안 바뀌면 유지)
const Child = memo(function Child() {
  const { isAuth, login, logout } = useContext(AuthContext);
  console.log("Child 렌더링");
  return (
    <div>
      <p>{isAuth ? "로그인됨" : "로그아웃됨"}</p>
      {isAuth ? (
        <button onClick={logout}>로그아웃</button>
      ) : (
        <button onClick={login}>로그인</button>
      )}
    </div>
  );
});

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <AuthProvider>
      <div className="test">
        <h1>useMemo 없이 쓴 경우</h1>
        <Child />
        <button onClick={() => setCount(count + 1)}>카운트 {count}</button>
      </div>
    </AuthProvider>
  );
}
```

### 실행 결과

버튼(카운트)을 눌러도 AuthProvider가 리렌더링됨 →
value 객체가 새로 만들어져서 Child도 매번 리렌더링 됨.

## 3. useMemo를 쓴 경우

```jsx
import {
  createContext,
  useContext,
  useState,
  useMemo,
  useCallback,
  memo,
} from "react";

const AuthContext = createContext(null);

function AuthProvider({ children }) {
  const [isAuth, setIsAuth] = useState(false);
  const login = useCallback(() => setIsAuth(true), []);
  const logout = useCallback(() => setIsAuth(false), []);

  // 컨텍스트 값 참조 안정화
  const value = useMemo(
    () => ({ isAuth, login, logout }),
    [isAuth, login, logout]
  );

  console.log("AuthProvider 렌더링");
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// memo로 부모 리렌더 시 불필요한 재호출을 회피 (컨텍스트 값이 안 바뀌면 유지)
const Child = memo(function Child() {
  const { isAuth, login, logout } = useContext(AuthContext);
  console.log("Child 렌더링");
  return (
    <div>
      <p>{isAuth ? "로그인됨" : "로그아웃됨"}</p>
      {isAuth ? (
        <button onClick={logout}>로그아웃</button>
      ) : (
        <button onClick={login}>로그인</button>
      )}
    </div>
  );
});

export default function App() {
  const [count, setCount] = useState(0);
  return (
    <AuthProvider>
      <div className="test">
        <h1>useMemo, useCallback 함께 쓴 경우</h1>
        <Child />
        <button onClick={() => setCount((c) => c + 1)}>카운트 {count}</button>
      </div>
    </AuthProvider>
  );
}
```

### 실행 결과

버튼(카운트)을 눌러도 AuthProvider만 리렌더링되고,
Child는 불필요하게 리렌더링되지 않음.

즉,

- useMemo 없으면: Provider의 value가 새로 생성되어 자식까지 다 리렌더링됨.

- useMemo 있으면: 실제 상태 값(isAuth)이 변할 때만 자식이 리렌더링됨.
