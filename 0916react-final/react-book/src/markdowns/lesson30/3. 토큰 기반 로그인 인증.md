# 3. 토큰 기반 로그인 인증

## 1. 용어 정리

- Access 토큰: “짧게 쓰는 신분증”. 요청 보낼 때 Authorization: Bearer <토큰>로 첨부. 몇 분~몇십 분이면 만료됨.

- Refresh 토큰: “오래 쓰는 열쇠”. Access가 만료되면 서버에 “새 신분증 주세요” 하고 교환. 보통 HttpOnly 쿠키로 보관(브라우저가 관리, JS로 못 읽음).

- 흐름: 로그인 시 둘 다 받음 → 평소엔 Access로 호출 → 401(만료)이면 Refresh로 새 Access 발급 → 계속 사용 → 로그아웃 시 둘 다 폐기.

## 2. 폴더 구조

```bash
my-auth-demo/
  server/           # Express (포트 4000) — 이전 코드 그대로
  client/           # Vite + React + Tailwind (포트 5173)
```

## 3. Express로 Server 만들기

### Express 설치

```bash
mkdir -p my-auth-demo/server
cd my-auth-demo/server
npm init -y
npm i express cors cookie-parser jsonwebtoken
```

- -p 옵션은 중간 경로가 없으면 새로 생성함. (-p 옵션이 없으면 중간 폴더가 없으면 에러남.)

### /server/index.js

```js
// server/index.js
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import jwt from "jsonwebtoken";

const app = express();
const PORT = 4000;

// ★ 데모용 비밀키(실무는 .env로 관리)
const ACCESS_SECRET = "access-secret-demo";
const REFRESH_SECRET = "refresh-secret-demo";

// CORS: 클라이언트 주소 허용 + 쿠키 전달 허용
app.use(
  cors({
    origin: [
      "http://localhost:5173",
      "http://localhost:5174",
      "http://localhost:5175",
      "http://localhost:5176",
    ],
    credentials: true, // credentials:true와 origin:"*"은 같이 못 씀
  })
);
app.use(express.json());
app.use(cookieParser());

// ---- (1) 메모리 사용자 DB (데모) ----
const users = [
  {
    id: "u1",
    username: "test",
    password: "1234",
    name: "홍길동",
    role: "user",
  },
];

// ---- (2) 메모리 Refresh 저장소 (jti 기반) ----
// key: userId, value: { jti: "...", ua: "...", exp: number(옵션) }
const refreshStore = new Map();

// ---- (3) JWT 유틸 ----
function signAccess(user) {
  return jwt.sign(
    { sub: user.id, name: user.name, role: user.role },
    ACCESS_SECRET,
    { expiresIn: "10m" } // Access는 짧게
  );
}
function signRefresh(user, jti) {
  return jwt.sign({ sub: user.id, jti }, REFRESH_SECRET, { expiresIn: "7d" });
}
function setRefreshCookie(res, token) {
  res.cookie("refreshToken", token, {
    httpOnly: true, // JS로 읽기 불가
    secure: false, // 데모이므로 http. 배포는 true(HTTPS 필수)
    sameSite: "lax",
    path: "/auth/refresh",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });
}
function randomJti() {
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

// ---- (4) 로그인 ----
app.post("/auth/login", (req, res) => {
  const { username, password } = req.body || {};
  const user = users.find(
    (u) => u.username === username && u.password === password
  );
  if (!user) return res.status(401).json({ error: "Invalid credentials" });

  const accessToken = signAccess(user);
  const jti = randomJti();
  const refreshToken = signRefresh(user, jti);

  refreshStore.set(user.id, { jti, ua: req.headers["user-agent"] || "" });
  setRefreshCookie(res, refreshToken);
  res.json({
    accessToken,
    user: { id: user.id, name: user.name, role: user.role },
  });
});

// ---- (5) Access 검증 미들웨어 ----
function requireAuth(req, res, next) {
  const auth = req.headers.authorization || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7) : null;
  if (!token) return res.status(401).json({ error: "No token" });
  try {
    const payload = jwt.verify(token, ACCESS_SECRET); // { sub, name, role, iat, exp }
    req.user = payload;
    next();
  } catch {
    return res.status(401).json({ error: "Invalid or expired access token" });
  }
}

// ---- (6) 보호된 API ----
app.get("/api/me", requireAuth, (req, res) => {
  res.json({ userId: req.user.sub, name: req.user.name, role: req.user.role });
});

// ---- (7) 토큰 재발급(회전) ----
app.post("/auth/refresh", (req, res) => {
  const token = req.cookies.refreshToken;
  if (!token) return res.status(401).json({ error: "No refresh cookie" });

  let payload;
  try {
    payload = jwt.verify(token, REFRESH_SECRET); // { sub, jti, iat, exp }
  } catch {
    return res.status(401).json({ error: "Invalid/expired refresh token" });
  }

  const record = refreshStore.get(payload.sub);
  // 재사용/변조 탐지: 저장된 jti와 다르면 세션 폐기
  if (!record || record.jti !== payload.jti) {
    refreshStore.delete(payload.sub);
    return res.status(401).json({ error: "Refresh reuse detected" });
  }

  // 회전: 새 jti + 새 Refresh + 새 Access
  const user = users.find((u) => u.id === payload.sub);
  if (!user) return res.status(401).json({ error: "User not found" });

  const accessToken = signAccess(user);
  const newJti = randomJti();
  const newRefresh = signRefresh(user, newJti);

  refreshStore.set(user.id, {
    jti: newJti,
    ua: req.headers["user-agent"] || "",
  });
  setRefreshCookie(res, newRefresh);
  res.json({ accessToken });
});

// ---- (8) 로그아웃 ----
app.post("/auth/logout", (req, res) => {
  const token = req.cookies.refreshToken;
  if (token) {
    try {
      const { sub } = jwt.verify(token, REFRESH_SECRET);
      refreshStore.delete(sub);
    } catch {}
  }
  res.clearCookie("refreshToken", { path: "/auth/refresh" });
  res.json({ ok: true });
});

// ---- (9) 서버 시작 ----
app.listen(PORT, () => {
  console.log(`Server running: http://localhost:${PORT}`);
});
```

### 실행

```bash
node index.js
```

## 4 Vite로 Client 만들기

```bash
cd ../
mkdir client
cd client
npm create vite@latest . -- --template react
npm i
```

## 5 AuthContext.jsx

```jsx
// client/src/hooks/AuthContext.jsx
import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useState,
} from "react";

const AuthContext = createContext(null);
const BASE = "http://localhost:4000";

export function AuthProvider({ children }) {
  const [accessToken, setAccessToken] = useState(null);
  const [me, setMe] = useState(null); // 로그인 사용자 정보(선택)
  const [status, setStatus] = useState(""); // 단순 상태 문자열(선택)

  // 로그인: 서버에서 access + refresh(cookie) 수신
  const login = useCallback(async (username, password) => {
    setStatus("로그인 중…");
    const res = await fetch(`${BASE}/auth/login`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include", // refresh 쿠키 수신
      body: JSON.stringify({ username, password }),
    });
    if (!res.ok) {
      setStatus("로그인 실패");
      throw new Error("Login failed");
    }
    const data = await res.json(); // { accessToken, user }
    setAccessToken(data.accessToken);
    setMe(data.user ?? null);
    setStatus("로그인 성공");
    return data.user ?? null;
  }, []);

  // 보호 API 호출: 401이면 refresh → 재시도
  const fetchWithAuth = useCallback(
    async (path, options = {}) => {
      const headers = {
        ...(options.headers || {}),
        ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
        "Content-Type": "application/json",
      };

      let res = await fetch(`${BASE}${path}`, {
        ...options,
        headers,
        credentials: "include",
      });

      if (res.status !== 401) return res;

      // 401 → refresh 시도
      const r = await fetch(`${BASE}/auth/refresh`, {
        method: "POST",
        credentials: "include",
      });
      if (!r.ok) {
        // refresh 실패 → 세션 정리
        setAccessToken(null);
        setMe(null);
        throw new Error("Failed to refresh");
      }
      const { accessToken: newToken } = await r.json();
      setAccessToken(newToken);

      // 재시도
      const headers2 = {
        ...(options.headers || {}),
        Authorization: `Bearer ${newToken}`,
        "Content-Type": "application/json",
      };
      return fetch(`${BASE}${path}`, {
        ...options,
        headers: headers2,
        credentials: "include",
      });
    },
    [accessToken]
  );

  // 로그아웃: 서버/쿠키/클라이언트 정리
  const logout = useCallback(async () => {
    await fetch(`${BASE}/auth/logout`, {
      method: "POST",
      credentials: "include",
    });
    setAccessToken(null);
    setMe(null);
    setStatus("로그아웃 완료");
  }, []);

  const value = useMemo(
    () => ({
      accessToken,
      me,
      status,
      setStatus,
      login,
      fetchWithAuth,
      logout,
    }),
    [accessToken, me, status, login, fetchWithAuth, logout]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  return useContext(AuthContext);
}
```

## 6. main.jsx

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";
import { AuthProvider } from "./hooks/AuthContext.jsx";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <AuthProvider>
      <App />
    </AuthProvider>
  </StrictMode>
);
```

## 7. components

### Button.jsx

```jsx
export default function Button({ className = "", ...props }) {
  return (
    <button
      className={
        "px-4 py-2 border border-neutral-800 bg-neutral-900 text-white hover:bg-neutral-800 active:bg-black rounded-none " +
        className
      }
      {...props}
    />
  );
}
```

### Card.jsx

```jsx
export default function Card({ title, children, footer }) {
  return (
    <div className="border border-neutral-200 bg-white rounded-none">
      {title && (
        <div className="px-4 py-3 border-b border-neutral-200 text-base font-semibold">
          {title}
        </div>
      )}
      <div className="p-4">{children}</div>
      {footer && (
        <div className="px-4 py-3 border-t border-neutral-200">{footer}</div>
      )}
    </div>
  );
}
```

### Header.jsx

```jsx
export default function Header() {
  return (
    <header className="border-b border-neutral-200 bg-white">
      <div className="mx-auto max-w-xl px-4 py-3">
        <h1 className="text-lg font-bold tracking-tight">
          Access / Refresh Token Demo
        </h1>
      </div>
    </header>
  );
}
```

### Input.jsx

```jsx
export default function Input({ className = "", label, ...props }) {
  return (
    <label className="block">
      {label && (
        <span className="mb-1 block text-sm text-neutral-700">{label}</span>
      )}
      <input
        className={
          "w-full border border-neutral-300 focus:border-neutral-900 focus:outline-none px-3 py-2 rounded-none " +
          className
        }
        {...props}
      />
    </label>
  );
}
```

## 8. App.jsx

```jsx
import { useState } from "react";
import { useAuth } from "./hooks/AuthContext.jsx";
import Header from "./components/Header";
import Card from "./components/Card";
import Button from "./components/Button";
import Input from "./components/Input";

export default function App() {
  const { accessToken, me, status, setStatus, login, fetchWithAuth, logout } =
    useAuth();
  const [username, setUsername] = useState("test");
  const [password, setPassword] = useState("1234");

  const onLogin = async () => {
    try {
      await login(username, password);
    } catch {
      // 상태는 컨텍스트에서 이미 갱신됨
    }
  };

  const onMe = async () => {
    setStatus("/api/me 호출 중…");
    try {
      const res = await fetchWithAuth("/api/me");
      if (!res.ok) throw new Error("me failed");
      const data = await res.json();
      // me는 서버에서 user 정보를 줬을 때만 자동 세팅됨.
      // /api/me는 보호 엔드포인트니까 여기서는 결과만 보여줌
      setStatus("성공");
      console.log("me:", data);
      alert(JSON.stringify(data, null, 2));
    } catch (e) {
      setStatus("실패: " + e.message);
    }
  };

  const onLogout = async () => {
    await logout();
  };

  return (
    <div className="min-h-screen bg-neutral-50">
      <Header />
      <main className="mx-auto max-w-xl px-4 py-8 space-y-6">
        {!accessToken ? (
          <Card title="로그인">
            <div className="space-y-3">
              <Input
                label="아이디"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
              />
              <Input
                label="비밀번호"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
              <div className="flex items-center gap-2">
                <Button onClick={onLogin} className="w-full">
                  로그인
                </Button>
              </div>
              <p className="text-sm text-neutral-600">
                데모 계정: 아이디{" "}
                <code className="px-1 bg-neutral-100">test</code>, 비밀번호{" "}
                <code className="px-1 bg-neutral-100">1234</code>
              </p>
            </div>
          </Card>
        ) : (
          <Card title="토큰 상태">
            <div className="space-y-2">
              <div className="text-sm text-neutral-700">
                Access 토큰:{" "}
                <span className="font-mono">{accessToken.slice(0, 16)}…</span>
              </div>
              <div className="flex items-center gap-2">
                <Button onClick={onMe}>/api/me 호출</Button>
                <Button
                  onClick={onLogout}
                  className="border-neutral-500 bg-white text-neutral-900 hover:bg-neutral-100"
                >
                  로그아웃
                </Button>
              </div>
              <p className="text-sm text-neutral-600">
                Refresh 토큰은 HttpOnly 쿠키로 보관되어 JS로는 보이지 않습니다.
              </p>
            </div>
          </Card>
        )}

        <Card title="로그인 사용자(서버 응답)">
          <pre className="text-sm bg-neutral-100 p-3 overflow-auto rounded-none">
            {JSON.stringify(me, null, 2)}
          </pre>
        </Card>

        <Card title="개념 요약">
          <ul className="list-disc pl-5 space-y-1 text-sm text-neutral-800">
            <li>
              <span className="font-semibold">Access</span>: 짧게 쓰는 로그인
              증명서. 요청 시 Bearer 헤더로 전송
            </li>
            <li>
              <span className="font-semibold">Refresh</span>: 오래 보관하는
              열쇠. 만료 시 새 Access 발급(쿠키)
            </li>
            <li>
              흐름: 로그인 → Access로 호출 → 401이면 Refresh로 재발급 → 재시도 →
              로그아웃
            </li>
          </ul>
        </Card>
      </main>
    </div>
  );
}
```

## 9. 정리

### 흐름

- 브라우저 http://localhost:5173
- 아이디 test, 비번 1234 로그인
- /api/me 호출
- Access 만료 시 (401) 자동으로 /auth/refresh 요청
- 로그아웃

### 요약

- Context API로 토큰/유저/상태 + login/fetchWithAuth/logout을 한 곳에서 관리하고, 컴포넌트에서 쓸 때는 useAuth로 간단히 사용합니다.

- Access는 메모리, Refresh는 HttpOnly 쿠키로 분리해 안전한 인증 흐름을 만들 수 있습니다.
