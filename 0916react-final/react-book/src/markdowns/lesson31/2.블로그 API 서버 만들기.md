# 2단계. 블로그 API 서버 만들기

## MySQL 스키마 정의

```sql
CREATE DATABASE IF NOT EXISTS myschema DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
USE myschema;

CREATE TABLE IF NOT EXISTS blog_users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password VARCHAR(255) NOT NULL, -- 평문 저장(학습용)
  nick VARCHAR(50) NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS blog_posts (
  id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT,
  category VARCHAR(100) NOT NULL,
  title VARCHAR(255) NOT NULL,
  content LONGTEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES blog_users(id) ON DELETE SET NULL
) ENGINE=InnoDB;


```

## 샘플 데이터 (INSERT 구문)

```sql
USE myschema;

-- 유저 샘플
INSERT INTO blog_users (email, password, nick)
VALUES
('alice@example.com', 'password123', 'Alice'),
('bob@example.com', '1234', 'Bob'),
('charlie@example.com', 'letmein', 'Charlie');

-- 포스트 샘플
INSERT INTO blog_posts (user_id, category, title, content)
VALUES
(1, 'Tech', 'Express + React 블로그 만들기 튜토리얼',
 REPEAT(
  '이 글은 Express 서버와 React 클라이언트를 이용해 블로그를 만드는 과정을 자세하게 설명합니다. 데이터베이스 연결, REST API 설계, JWT 로그인, 프로필 관리, 게시글 CRUD 등 전반적인 흐름을 따라가며 학습할 수 있습니다. 실제 현업에서 필요한 코드 패턴을 소개하고, 초보자들이 실수를 줄일 수 있도록 주의할 점을 꼼꼼히 짚어줍니다. 또한, Tailwind CSS를 활용한 UI 컴포넌트화, React Router를 이용한 페이지 라우팅, Context API를 이용한 전역 상태 관리까지 포괄적으로 다루며 학습자들이 프로젝트를 직접 완성할 수 있도록 돕습니다. ', 20)
),
(2, 'Travel', '일본 삿포로 여행 후기',
 REPEAT(
  '삿포로 여행은 겨울에 특히 매력적인 도시입니다. 눈축제, 온천, 맛있는 라멘과 맥주까지 즐길 거리가 넘쳐납니다. 이번 여행에서는 삿포로 시내뿐만 아니라 오타루, 노보리베츠 같은 인근 도시도 다녀왔습니다. 특히 오타루 운하는 저녁에 불빛이 반짝이는 모습이 정말 인상 깊었고, 노보리베츠 온천에서는 피로가 싹 풀렸습니다. 현지 음식으로는 스프 카레와 게 요리를 꼭 추천합니다. 교통도 편리해서 JR 패스를 이용하면 자유롭게 다닐 수 있었고, 일본 특유의 친절함 덕분에 여행 내내 편안했습니다. ', 20)
),
(3, 'Life', '일상 속 작은 루틴이 주는 변화',
 REPEAT(
  '매일 아침 10분 스트레칭, 하루에 1페이지 독서, 자기 전 감사일기 쓰기 같은 작은 습관들이 삶의 질을 크게 바꿀 수 있습니다. 처음에는 사소해 보이지만, 시간이 쌓이면 집중력, 정신 건강, 행복감이 달라집니다. 특히 꾸준히 일기를 쓰면 스스로를 돌아보고, 하루를 정리하는 힘이 생깁니다. 또 몸을 가볍게 움직이는 루틴은 건강뿐 아니라 마음에도 활력을 줍니다. 결국 거대한 목표도 작은 습관에서 시작된다는 것을 체감할 수 있었고, 이것이 일상을 특별하게 만들어 줍니다. ', 20)
);

```

## 폴더 구조

```bash
server/
  package.json
  .env
  src/
    server.js
    db.js
    middleware/
      auth.js
    routes/
      auth.js
      users.js
      posts.js
```

## express 서버 만들기

```bash
cd server
npm init -y
npm i express cors dotenv mysql2 cookie-parser jsonwebtoken
npm i -D nodemon
```

### package.json

#### 아래 내용을 추가하기

```json
{
  "type": "module",
  "scripts": {
    "dev": "nodemon src/server.js",
    "start": "node src/server.js"
  }
}
```

#### 전체 package.json

```json
{
  "name": "server",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "dev": "nodemon ./src/server.js",
    "start": "node ./src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.2.2",
    "express": "^5.1.0",
    "jsonwebtoken": "^9.0.2",
    "mysql2": "^3.14.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}
```

## .env (예시)

```bash
PORT=4000
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=mysql1234
DB_DATABASE=myschema
JWT_SECRET=super_secret_please_change
JWT_EXPIRES=7d
COOKIE_NAME=access_token
CLIENT_ORIGIN=http://localhost:5173
```

## DB 커넥션: src/db.js

```js
import mysql from "mysql2/promise";
import dotenv from "dotenv";
dotenv.config();

export const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE, // myschema
  waitForConnections: true,
  connectionLimit: 10,
});
```

## 인증 미들웨어: src/middleware/auth.js

```js
import jwt from "jsonwebtoken";

export function requireAuth(req, res, next) {
  try {
    const name = process.env.COOKIE_NAME;
    const token = req.signedCookies?.[name] || req.cookies?.[name];
    if (!token) return res.status(401).json({ message: "Unauthenticated" });
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = { id: payload.id, email: payload.email, nick: payload.nick };
    next();
  } catch (e) {
    return res.status(401).json({ message: "Invalid token" });
  }
}

/* 글 소유자만 수정/삭제 허용 (옵션) */
export function requireOwner(getOwnerId) {
  return async (req, res, next) => {
    try {
      const ownerId = await getOwnerId(req); // 숫자
      if (!req.user || !ownerId || req.user.id !== ownerId) {
        return res.status(403).json({ message: "Forbidden" });
      }
      next();
    } catch {
      res.status(500).json({ message: "Owner check failed" });
    }
  };
}
```

## 포스트 라우트: src/routes/posts.js

```js
import { Router } from "express";
import { pool } from "../db.js";
import { requireAuth, requireOwner } from "../middleware/auth.js";

const router = Router();

/* 목록: GET /posts?page=1&size=10&category=Tech&kw=foo */
router.get("/", async (req, res) => {
  const page = Math.max(parseInt(req.query.page || "1", 10), 1);
  const size = Math.max(parseInt(req.query.size || "10", 10), 1);
  const offset = (page - 1) * size;

  const { category, kw } = req.query;
  const cond = [];
  const params = [];

  if (category) {
    cond.push("p.category=?");
    params.push(category);
  }
  if (kw) {
    cond.push("(p.title LIKE ? OR p.content LIKE ?)");
    params.push(`%${kw}%`, `%${kw}%`);
  }

  const where = cond.length ? `WHERE ${cond.join(" AND ")}` : "";

  const [[{ total }]] = await pool.query(
    `SELECT COUNT(*) AS total FROM blog_posts p ${where}`,
    params
  );

  const [rows] = await pool.query(
    `SELECT p.id, p.user_id, p.category, p.title, p.content, p.created_at, p.updated_at,
            u.nick AS author_nick, u.email AS author_email
       FROM blog_posts p
  LEFT JOIN blog_users u ON u.id = p.user_id
       ${where}
   ORDER BY p.id DESC
      LIMIT ? OFFSET ?`,
    [...params, size, offset]
  );

  res.json({ page, size, total, rows });
});

/* 단건 조회: GET /posts/:id */
router.get("/:id", async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const [rows] = await pool.query(
    `SELECT p.*, u.nick AS author_nick, u.email AS author_email
       FROM blog_posts p
  LEFT JOIN blog_users u ON u.id = p.user_id
      WHERE p.id=?`,
    [id]
  );
  const row = rows[0];
  if (!row) return res.status(404).json({ message: "Not found" });
  res.json(row);
});

/* 생성: POST /posts (로그인 필요) */
router.post("/", requireAuth, async (req, res) => {
  const { category, title, content } = req.body || {};
  if (!category || !title || !content)
    return res.status(400).json({ message: "category/title/content required" });

  const userId = req.user.id;
  const [r] = await pool.query(
    "INSERT INTO blog_posts (user_id, category, title, content) VALUES (?, ?, ?, ?)",
    [userId, category, title, content]
  );
  res.status(201).json({ id: r.insertId });
});

/* 소유자 조회 유틸 */
async function getPostOwnerId(req) {
  const id = parseInt(req.params.id, 10);
  const [rows] = await pool.query("SELECT user_id FROM blog_posts WHERE id=?", [
    id,
  ]);
  return rows[0]?.user_id || null;
}

/* 수정: PUT /posts/:id (소유자만) */
router.put(
  "/:id",
  requireAuth,
  requireOwner(getPostOwnerId),
  async (req, res) => {
    const id = parseInt(req.params.id, 10);
    const { category, title, content } = req.body || {};
    if (!category || !title || !content)
      return res
        .status(400)
        .json({ message: "category/title/content required" });

    await pool.query(
      "UPDATE blog_posts SET category=?, title=?, content=? WHERE id=?",
      [category, title, content, id]
    );
    res.json({ ok: true });
  }
);

/* 삭제: DELETE /posts/:id (소유자만) */
router.delete(
  "/:id",
  requireAuth,
  requireOwner(getPostOwnerId),
  async (req, res) => {
    const id = parseInt(req.params.id, 10);
    await pool.query("DELETE FROM blog_posts WHERE id=?", [id]);
    res.json({ ok: true });
  }
);

export default router;
```

## 인증/유저 라우트: src/routes/auth.js

```js
import { Router } from "express";
import { pool } from "../db.js";
import jwt from "jsonwebtoken";

const router = Router();
const cookieName = process.env.COOKIE_NAME;

function setTokenCookie(res, payload) {
  const token = jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES,
  });
  res.cookie(cookieName, token, {
    httpOnly: true,
    sameSite: "lax",
    secure: false, // 로컬 http 개발용. 배포시 true(HTTPS)
    maxAge: 7 * 24 * 3600 * 1000,
  });
}

/* 회원가입 */
router.post("/register", async (req, res) => {
  const { email, password, nick } = req.body || {};
  if (!email || !password || !nick)
    return res.status(400).json({ message: "email/password/nick required" });

  const [dup] = await pool.query("SELECT id FROM blog_users WHERE email=?", [
    email,
  ]);
  if (dup.length)
    return res.status(409).json({ message: "Email already exists" });

  const [r] = await pool.query(
    "INSERT INTO blog_users (email, password, nick) VALUES (?, ?, ?)",
    [email, password, nick] // 평문 저장(학습용)
  );

  const payload = { id: r.insertId, email, nick };
  setTokenCookie(res, payload);
  res.status(201).json(payload);
});

/* 로그인 */
router.post("/login", async (req, res) => {
  const { email, password } = req.body || {};
  const [rows] = await pool.query(
    "SELECT id, email, password, nick FROM blog_users WHERE email=?",
    [email]
  );
  const user = rows[0];
  if (!user || user.password !== password)
    return res.status(401).json({ message: "Invalid credentials" });

  const payload = { id: user.id, email: user.email, nick: user.nick };
  setTokenCookie(res, payload);
  res.json(payload);
});

/* 내 정보 */
router.get("/me", async (req, res) => {
  try {
    const token = req.signedCookies?.[cookieName] || req.cookies?.[cookieName];
    if (!token) return res.json(null);
    const p = jwt.verify(token, process.env.JWT_SECRET);
    res.json({ id: p.id, email: p.email, nick: p.nick });
  } catch {
    res.json(null);
  }
});

/* 로그아웃 */
router.post("/logout", (req, res) => {
  res.clearCookie(cookieName, {
    httpOnly: true,
    sameSite: "lax",
    secure: false,
  });
  res.json({ ok: true });
});

export default router;
```

## 유저 목록(관리/테스트용): src/routes/users.js

```js
import { Router } from "express";
import { pool } from "../db.js";

const router = Router();

/* GET /users?page=1&size=10 */
router.get("/", async (req, res) => {
  const page = Math.max(parseInt(req.query.page || "1", 10), 1);
  const size = Math.max(parseInt(req.query.size || "10", 10), 1);
  const offset = (page - 1) * size;

  const [[{ total }]] = await pool.query(
    "SELECT COUNT(*) AS total FROM blog_users"
  );
  const [rows] = await pool.query(
    `SELECT id, email, nick, created_at
       FROM blog_users
      ORDER BY id DESC
      LIMIT ? OFFSET ?`,
    [size, offset]
  );

  res.json({ page, size, total, rows });
});

export default router;
```

## 서버 엔트리: src/server.js

```js
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import dotenv from "dotenv";
import authRouter from "./routes/auth.js";
import usersRouter from "./routes/users.js";
import postsRouter from "./routes/posts.js";

dotenv.config();

const app = express();
app.use(express.json());
app.use(cookieParser(process.env.JWT_SECRET));

app.use(
  cors({
    origin: process.env.CLIENT_ORIGIN || "http://localhost:5173",
    credentials: true,
  })
);

app.get("/", (_, res) => res.json({ ok: true }));

app.use("/auth", authRouter); // register, login, me, logout
app.use("/users", usersRouter); // 목록(관리/테스트)
app.use("/posts", postsRouter); // CRUD(생성/수정/삭제는 로그인+소유자)

const port = process.env.PORT || 4000;
app.listen(port, () => console.log(`API on http://localhost:${port}`));
```
