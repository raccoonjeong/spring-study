# 1. useEffect와 라이프사이클

## 1. 컴포넌트 라이프사이클

리액트 함수형 컴포넌트도 등장하고(마운트), 값이 바뀌고(업데이트), 사라지는(언마운트) 흐름을 가집니다.

- **마운트**(Mount) :컴포넌트가 처음 화면에 나타날 때.

- **업데이트**(Update) : props 또는 state가 바뀌어 다시 렌더링될 때.

- **언마운트**(Unmount) : 컴포넌트가 화면에서 사라질 때.

useEffect는 이 3단계에서 동작을 제어할 수 있는 도구입니다.

## 2. useEffect란 무엇인가?

useEffect는 리액트 함수형 컴포넌트에서 자주 사용하는 훅(Hook) 중 하나로, `컴포넌트가 화면에 나타나거나`, `업데이트`되거나, `사라질 때` 특정 동작(부수 효과, side effect)을 실행하도록 도와줍니다.

단순히 JSX를 그리는 것과 달리, 컴포넌트 외부 환경에 영향을 주는 작업들을 "**부수 효과**(side effect)"라고 부릅니다. useEffect는 바로 이 부수 효과를 관리하는 훅입니다.

## 3.useEffect의 기본 문법

```jsx
import { useEffect } from "react";

useEffect(() => {
  // 실행할 코드 (effect)
  console.log("컴포넌트가 렌더링됨!");
});
```

위처럼 작성하면 컴포넌트가 **렌더링될 때마다** 이 코드가 실행됩니다.

하지만 대부분은 특정 상황에서만 실행되도록 제어가 필요합니다. 그럴 때 두 번째 인자인 **의존성 배열**(dependency array)을 사용합니다.

## 4. 의존성 배열(dependency array)

```jsx
useEffect(() => {
  console.log("한 번만 실행!");
}, []);
```

- [] (빈 배열): 마운트 시 딱 한 번만 실행. (예: 초기 데이터 불러오기)

```jsx
useEffect(() => {
  console.log("count 값이 바뀔 때마다 실행!");
}, [count]);
```

- [count]: count 상태가 바뀔 때마다 실행.

```jsx
useEffect(() => {
  console.log("count, page, id 값이 바뀔 때마다 실행!");
}, [count, page, id]);
```

- 배열 안에 여러 변수를 넣을 수도 있음.

```jsx
useEffect(() => {
  console.log("렌더링될 때마다 실행!");
});
```

- 의존성 배열을 아예 안 쓰면, 모든 렌더링마다 실행.

## 5. 정리(clean-up) 함수

컴포넌트가 사라지거나(effect가 다시 실행되기 직전) 정리 작업이 필요할 때 clean-up 함수를 반환합니다.

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log("타이머 실행 중");
  }, 1000);

  // 정리(clean-up)
  return () => {
    clearInterval(timer);
    console.log("타이머 종료");
  };
}, []);
```

이렇게 하면 메모리 누수를 막을 수 있습니다.

### 메모리 누수( Memory Leak )란?

- 프로그램이 더 이상 사용하지 않는 메모리를 계속 차지하고 놓아주지 않는 상태.
- 메모리 누수가 많으면, 에러가 발생하거나 전체 시스템 성능이 저하됨.

## 6. 예제: 데이터 불러오기

```jsx
import { useEffect, useState } from "react";

function PostList() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    const fetchData = async () => {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      const data = await res.json();
      setPosts(data.slice(0, 5)); // 앞 5개만
    };
    fetchData();
  }, []); // 마운트될 때 한 번만 실행

  return (
    <div>
      <h2>게시글 목록</h2>
      <ul>
        {posts.map((p) => (
          <li key={p.id}>{p.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

## 7. 예제: 이벤트 등록/해제

```jsx
import { useEffect, useState } from "react";

function WindowSize() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);

    window.addEventListener("resize", handleResize);

    // 정리(clean-up)
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);

  return <div>현재 창 너비: {width}px</div>;
}
```

## 8. 핵심 정리

```jsx
useEffect(() => { 실행 코드 }, [의존성]);
```

### 의존성 배열

- []: 처음 마운트 시 1번만 실행

- [변수]: 변수 값이 바뀔 때마다 실행

- 없음: 렌더링마다 실행

- 정리(clean-up) 함수는 꼭 필요할 때만 반환

### 자주 하는 실수

- 의존성 배열 빼먹기: 무한 호출 발생 가능

- 불필요한 의존성 넣기: 원치 않는 재실행

- 정리 함수 안 쓰기: 이벤트 중복 등록, 메모리 누수
