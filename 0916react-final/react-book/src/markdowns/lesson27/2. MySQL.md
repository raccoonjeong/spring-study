# 2. express 서버에 mysql 연동

## 1. npm으로 설치하기

```bash
npm i express cors mysql2
```

## 2. DB 테이블 생성하기

### 테이블 생성 SQL

```sql
CREATE DATABASE IF NOT EXISTS myschema DEFAULT CHARACTER SET utf8mb4;
USE myschema;

CREATE TABLE IF NOT EXISTS posts (
  id INT PRIMARY KEY AUTO_INCREMENT,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  category VARCHAR(100) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### id

고유 식별자(PK). 새 글이 추가될 때마다 자동으로 증가.

```sql
id INT PRIMARY KEY AUTO_INCREMENT
```

### title

글 제목. 최대 255자, 반드시 값이 있어야 함.

```sql
title VARCHAR(255) NOT NULL
```

### content

글 본문. 긴 문자열 저장 가능, 반드시 값이 있어야 함.

```sql
content TEXT NOT NULL
```

### category

글이 속한 카테고리. 최대 100자, 반드시 값이 있어야 함.

```sql
category VARCHAR(100) NOT NULL
```

### created_at

레코드 생성 시각. 기본값은 현재 시간.

```sql
created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
```

### updated_at

레코드 마지막 수정 시각. 처음엔 생성 시각과 같고, UPDATE 시 자동 갱신.

```sql
updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

### 샘플 데이터 넣기

```sql
USE myschema;

INSERT INTO posts (title, content, category)
VALUES
  ('첫 번째 글', 'Express와 MySQL 연동 테스트 글입니다.', 'js'),
  ('두 번째 글', 'React에서 fetch로 불러오기 예제.', 'react');
```

- id 컬럼은 AUTO_INCREMENT 이므로 따로 지정할 필요 없습니다.

- created_at, updated_at 은 기본값으로 CURRENT_TIMESTAMP 가 들어갑니다.

- 따라서 title, content, category 값만 넣으면 됩니다.

## 3. server.js 전체 코드

```js
import express from "express";
import cors from "cors";
import mysql from "mysql2/promise";

const app = express();
const PORT = process.env.PORT || 4000;

// ----- MySQL Pool -----
const pool = mysql.createPool({
  host: "localhost",
  user: "root",
  password: "mysql1234",
  database: "myschema",
  waitForConnections: true,
  connectionLimit: 10,
  namedPlaceholders: true, // :name 바인딩 허용
});

// 미들웨어
app.use(cors());
app.use(express.json());

// 공통 에러 헬퍼
const onError = (res, e) => {
  console.error(e);
  res.status(500).json({ message: "서버 오류가 발생했습니다." });
};

// 목록 조회
app.get("/posts", async (req, res) => {
  try {
    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts ORDER BY id DESC"
    );
    res.json(rows);
  } catch (e) {
    onError(res, e);
  }
});

// 상세보기
app.get("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);
    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    if (rows.length === 0)
      return res.status(404).json({ message: "해당하는 포스트가 없습니다." });
    res.json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});

// 새로 추가하기
app.post("/posts", async (req, res) => {
  try {
    const { title, content, category } = req.body || {};
    if (!title || !content || !category) {
      return res
        .status(400)
        .json({ message: "title, content, category는 필수입니다." });
    }

    const [result] = await pool.query(
      "INSERT INTO posts (title, content, category) VALUES (?, ?, ?)",
      [title, content, category]
    );

    const insertId = result.insertId;
    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [insertId]
    );
    res.status(201).json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});

// 삭제
app.delete("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);

    // 삭제 전 데이터 확보
    const [found] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    if (found.length === 0)
      return res.status(404).json({ message: "Post not found" });

    await pool.query("DELETE FROM posts WHERE id = ?", [id]);
    res.json({ message: "Deleted", post: found[0] });
  } catch (e) {
    onError(res, e);
  }
});

// 수정하기 (전체 교체: PUT)
app.put("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);
    const { title, content, category } = req.body || {};
    if (!title || !content || !category) {
      return res
        .status(400)
        .json({ message: "title, content, category 모두 필요합니다." });
    }

    const [exists] = await pool.query("SELECT id FROM posts WHERE id = ?", [
      id,
    ]);
    if (exists.length === 0)
      return res.status(404).json({ message: "Post not found" });

    await pool.query(
      "UPDATE posts SET title = ?, content = ?, category = ? WHERE id = ?",
      [title, content, category, id]
    );

    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    res.json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});

// 수정하기 (부분 수정: PATCH)
app.patch("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);
    const { title, content, category } = req.body || {};

    const [exists] = await pool.query("SELECT * FROM posts WHERE id = ?", [id]);
    if (exists.length === 0)
      return res.status(404).json({ message: "Post not found" });

    // 동적 업데이트 구성
    const fields = [];
    const values = [];
    if (title !== undefined) {
      fields.push("title = ?");
      values.push(title);
    }
    if (content !== undefined) {
      fields.push("content = ?");
      values.push(content);
    }
    if (category !== undefined) {
      fields.push("category = ?");
      values.push(category);
    }

    if (fields.length === 0) {
      return res.status(400).json({ message: "수정할 필드가 없습니다." });
    }

    values.push(id);
    await pool.query(
      `UPDATE posts SET ${fields.join(", ")} WHERE id = ?`,
      values
    );

    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    res.json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});

// 헬스 체크
app.get("/", (_req, res) => {
  res.send("Express posts API (MySQL) is running");
});

app.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}`);
});
```

## 4. [공통] MySQL 풀과 미들웨어

```js
import express from "express";
import cors from "cors";
import mysql from "mysql2/promise";

const app = express();
const PORT = process.env.PORT || 4000;

const pool = mysql.createPool({
  host: "localhost",
  port: 3306, // 도커 포트 매핑 시 바꾸세요
  user: "root",
  password: "mysql1234",
  database: "myschema",
  waitForConnections: true,
  connectionLimit: 10,
});

app.use(cors());
app.use(express.json());

const onError = (res, e) => {
  console.error(e);
  res.status(500).json({ message: "서버 오류가 발생했습니다." });
};
```

## 5. [목록 조회] GET /posts

- 역할: 전체 글 목록을 최신 글 먼저 반환.

- 쿼리: SELECT ... ORDER BY id DESC

```js
// 목록 조회
app.get("/posts", async (req, res) => {
  try {
    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts ORDER BY id DESC"
    );
    res.json(rows);
  } catch (e) {
    onError(res, e);
  }
});
```

## 6. [단건 조회] GET /posts/:id

- 역할: 특정 id의 글 한 건 반환.

- 예외: 없으면 404.

```js
// 상세보기
app.get("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);
    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    if (rows.length === 0) {
      return res.status(404).json({ message: "해당하는 포스트가 없습니다." });
    }
    res.json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});
```

## 7. [생성] POST /posts

- 역할: 새 글 추가.

- 유효성: title, content, category 필수.

- 반환: 방금 저장된 레코드(자동 증가 id 포함).

```js
// 새로 추가하기
app.post("/posts", async (req, res) => {
  try {
    const { title, content, category } = req.body || {};
    if (!title || !content || !category) {
      return res
        .status(400)
        .json({ message: "title, content, category는 필수입니다." });
    }

    const [result] = await pool.query(
      "INSERT INTO posts (title, content, category) VALUES (?, ?, ?)",
      [title, content, category]
    );

    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [result.insertId]
    );
    res.status(201).json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});
```

## 8. [전체 수정(치환)] PUT /posts/:id

- 역할: 해당 글의 title, content, category를 모두 교체.

- 유효성: 3개 모두 반드시 있어야 함.

- 예외: 대상 없으면 404.

```js
// 수정하기 (전체 교체: PUT)
app.put("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);
    const { title, content, category } = req.body || {};
    if (!title || !content || !category) {
      return res
        .status(400)
        .json({ message: "title, content, category 모두 필요합니다." });
    }

    const [exists] = await pool.query("SELECT id FROM posts WHERE id = ?", [
      id,
    ]);
    if (exists.length === 0) {
      return res.status(404).json({ message: "Post not found" });
    }

    await pool.query(
      "UPDATE posts SET title = ?, content = ?, category = ? WHERE id = ?",
      [title, content, category, id]
    );

    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    res.json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});
```

## 9. [부분 수정] PATCH /posts/:id

- 역할: 전달된 필드만 선택적으로 변경.

- 구현: 동적 쿼리로 전달된 필드만 세팅.

- 예외: 수정할 필드가 없으면 400, 대상 없으면 404.

```js
// 수정하기 (부분 수정: PATCH)
app.patch("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);
    const { title, content, category } = req.body || {};

    const [exists] = await pool.query("SELECT id FROM posts WHERE id = ?", [
      id,
    ]);
    if (exists.length === 0) {
      return res.status(404).json({ message: "Post not found" });
    }

    const fields = [];
    const values = [];

    if (title !== undefined) {
      fields.push("title = ?");
      values.push(title);
    }
    if (content !== undefined) {
      fields.push("content = ?");
      values.push(content);
    }
    if (category !== undefined) {
      fields.push("category = ?");
      values.push(category);
    }

    if (fields.length === 0) {
      return res.status(400).json({ message: "수정할 필드가 없습니다." });
    }

    values.push(id);
    await pool.query(
      `UPDATE posts SET ${fields.join(", ")} WHERE id = ?`,
      values
    );

    const [rows] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    res.json(rows[0]);
  } catch (e) {
    onError(res, e);
  }
});
```

## 10. [삭제] DELETE /posts/:id

- 역할: 해당 글 삭제.

- 반환: 삭제된 레코드(백엔드에서 먼저 조회해서 담아둠).

- 예외: 대상 없으면 404.

```js
// 삭제
app.delete("/posts/:id", async (req, res) => {
  try {
    const id = Number(req.params.id);

    // 삭제 전 데이터 확보
    const [found] = await pool.query(
      "SELECT id, title, content, category, created_at, updated_at FROM posts WHERE id = ?",
      [id]
    );
    if (found.length === 0) {
      return res.status(404).json({ message: "Post not found" });
    }

    await pool.query("DELETE FROM posts WHERE id = ?", [id]);
    res.json({ message: "Deleted", post: found[0] });
  } catch (e) {
    onError(res, e);
  }
});
```

## 11. 상태 코드 설명

### 200 OK

의미: 요청이 성공적으로 처리되었음.

사용한 곳:

- GET /posts (목록 조회 성공)

- GET /posts/:id (단건 조회 성공)

- PUT /posts/:id (전체 수정 성공)

- PATCH /posts/:id (부분 수정 성공)

- DELETE /posts/:id (삭제 성공)

특징: 일반적인 성공 응답에 사용.

### 201 Created

의미: 새 리소스가 생성됨.

사용한 곳:

- POST /posts (새 글 추가 성공 시)

특징: 201을 쓰면 단순 성공(200)과 달리 "새로 만들었다"는 의미를 명확히 전달.

- 보통 생성된 리소스를 응답 body에 포함시킴.

### 400 Bad Request

의미: 클라이언트가 잘못된 요청을 보냄. (서버는 이해했지만 실행 불가)

사용한 곳:

- POST /posts → title, content, category 중 하나 빠졌을 때

- PUT /posts/:id → 필수 값 빠졌을 때

- PATCH /posts/:id → 수정할 필드가 아예 없을 때

특징: 보통 유효성 검증 실패나 필수 데이터 누락 상황에서 사용.

### 404 Not Found

의미: 요청한 리소스를 서버에서 찾을 수 없음.

사용한 곳:

- GET /posts/:id → 해당 id 글이 없을 때

- PUT /posts/:id → 해당 id 글이 없을 때

- PATCH /posts/:id → 해당 id 글이 없을 때

- DELETE /posts/:id → 해당 id 글이 없을 때

특징: 존재하지 않는 리소스 요청을 나타낼 때 가장 많이 쓰임.

### 500 Internal Server Error

의미: 서버 내부 처리 중 예기치 못한 오류.

사용한 곳:

- 모든 라우터의 try/catch → DB 연결 오류, 쿼리 실패 등 예외 발생 시

특징: 클라이언트 요청이 잘못된 게 아니라, 서버 쪽 문제임을 알림.

### 요약

- 200 OK → 일반 성공

- 201 Created → 새로 생성 성공

- 400 Bad Request → 잘못된 요청(데이터 누락/형식 오류)

- 404 Not Found → 해당 리소스 없음

- 500 Internal Server Error → 서버 내부 오류
